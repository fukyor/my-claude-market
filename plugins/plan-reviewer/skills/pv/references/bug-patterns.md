# 常见Bug模式识别指南

本文档列出了在审查技术计划时应警惕的常见bug模式。

## 目录
- [状态相关Bug](#状态相关bug)
- [资源管理Bug](#资源管理bug)
- [并发相关Bug](#并发相关bug)
- [输入验证Bug](#输入验证bug)
- [API设计Bug](#api设计bug)
- [数据库相关Bug](#数据库相关bug)

---

## 状态相关Bug

### 1. 状态不一致
**模式**：多个地方修改同一状态，但未同步
```
计划问题：
- 在函数A中修改全局变量X
- 在函数B中也修改全局变量X
- 未考虑并发调用

建议：使用单一状态管理或添加锁机制
```

### 2. 遗忘的状态转换
**模式**：某些状态转换路径未处理
```
计划问题：
- 处理了 创建→进行中→完成
- 忽略了 创建→取消
- 忽略了 进行中→失败

建议：绘制完整状态转换图，确保全覆盖
```

### 3. 魔法值
**模式**：使用硬编码值表示状态
```
计划问题：
- if (status == 1) // 1是什么？

建议：使用枚举或常量
```

---

## 资源管理Bug

### 1. 资源泄漏
**模式**：打开的资源未关闭
```
计划问题：
- 打开文件读取，但异常时未关闭
- 创建连接，成功路径关闭但失败路径未关闭

建议：使用try-finally或with语句
```

### 2. 双重释放
**模式**：同一资源被释放两次
```
计划问题：
- 函数A释放资源
- 函数B也释放同一资源

建议：明确资源所有权
```

### 3. 使用已释放资源
**模式**：资源释放后继续使用
```
计划问题：
- 关闭文件后继续写入
- 释放内存后继续访问

建议：确保生命周期清晰
```

---

## 并发相关Bug

### 1. 竞态条件
**模式**：多线程/协程访问共享资源无保护
```
计划问题：
- 多个goroutine同时写入map
- 无锁的全局计数器

建议：使用mutex或原子操作
```

### 2. 死锁
**模式**：资源获取顺序不一致
```
计划问题：
- 线程1：获取锁A→锁B
- 线程2：获取锁B→锁A

建议：统一锁获取顺序
```

### 3. 惊群效应
**模式**：大量goroutine等待同一事件
```
计划问题：
- 为每个连接创建goroutine轮询

建议：使用epoll/select或连接池
```

---

## 输入验证Bug

### 1. 未验证外部输入
**模式**：直接使用用户输入或API响应
```
计划问题：
- 直接将用户输入拼接到SQL
- 不检查文件路径遍历
- 不验证数组边界

建议：始终验证、清理、限制输入
```

### 2. 假设数据格式
**模式**：假设数据总是符合预期
```
计划问题：
- 假设JSON字段总是存在
- 假设数组总是非空
- 假设字符串总是有效UTF-8

建议：添加显式检查和默认值
```

### 3. 整数溢出
**模式**：算术运算未检查溢出
```
计划问题：
- size = count * item_size // 可能溢出
- index = offset + delta // 可能溢出

建议：使用大整数类型或预先检查
```

---

## API设计Bug

### 1. 不一致的错误处理
**模式**：有时返回error，有时panic
```
计划问题：
- 函数A：返回error
- 函数B：panic on error
- 调用方无法统一处理

建议：统一错误处理策略
```

### 2. 接口泄露实现
**模式**：接口暴露内部细节
```
计划问题：
- 要求调用方理解内部状态机
- 返回内部结构的指针

建议：隐藏实现细节，提供清晰接口
```

### 3. 过于宽泛的接口
**模式**：函数/方法做太多事情
```
计划问题：
- ProcessAndValidateAndSave(data) // 违反单一职责

建议：拆分为独立的函数
```

---

## 数据库相关Bug

### 1. N+1查询
**模式**：循环中执行查询
```
计划问题：
- for user in users:
    get_posts(user.id) // N次查询

建议：使用JOIN或批量查询
```

### 2. 事务边界错误
**模式**：事务范围过大或过小
```
计划问题：
- 整个请求在一个事务中（持有锁太久）
- 部分操作在事务外（数据不一致）

建议：精确控制事务范围
```

### 3. 缺失索引
**模式**：常见查询条件无索引
```
计划问题：
- WHERE status = 'active' AND created_at > ?
- status字段无索引

建议：审查查询模式，添加必要索引
```

### 4. 软删除陷阱
**模式**：查询时忘记软删除过滤
```
计划问题：
- SELECT * FROM users WHERE email = ?
- 未检查deleted_at

建议：统一使用带软删除的查询方法
```

---

## 计划审查检查清单

使用此清单快速扫描计划中的潜在bug模式：

```
□ 状态修改：是否有多处修改同一状态？是否有遗漏的转换？
□ 资源管理：所有打开的资源是否都确保关闭？
□ 并发安全：共享变量是否有保护？锁顺序是否一致？
□ 输入验证：外部输入是否验证？边界是否检查？
□ 错误处理：所有错误路径是否覆盖？是否静默失败？
□ 数据库：是否有N+1查询？事务边界是否正确？
□ 时间处理：时区是否一致？时间比较是否正确？
□ 空值处理：是否有nil/None/null的检查？
□ 类型转换：是否安全？是否会丢失精度？
□ 配置管理：敏感信息是否硬编码？配置是否可覆盖？
```

---

## 计划特有Bug模式

### 1. 行号漂移
**模式**：前面步骤的代码修改导致后续步骤引用的行号不再准确
```
计划问题：
- 步骤1：在 https.go 第100行插入20行代码
- 步骤3：修改 https.go 第225-310行（ConnectAccept case）
- 实际：步骤1执行后，原第225行已变为第245行

建议：使用函数名/代码标记定位，而非依赖行号
```

### 2. 步骤间命名不一致
**模式**：不同步骤中对同一新增元素使用了不同的名称
```
计划问题：
- 步骤1：添加字段 ParentSession int64
- 步骤4：使用 ConnectionInfo{ParentID: xxx}  // 名称不一致

建议：在计划开头统一定义所有新增元素的命名，后续步骤严格引用
```

### 3. defer 在循环中
**模式**：计划代码中在 for 循环内使用 defer，导致资源释放延迟到函数退出而非每次迭代结束
```go
// 计划问题：
for !reqReader.IsEOF() {
    req, err := reqReader.ReadRequest()
    requestContext, finishRequest := context.WithCancel(req.Context())
    defer finishRequest()  // ⚠️ 只在函数退出时执行，不在每次迭代结束时执行
    // ...
}

// 建议：改用匿名函数包裹或显式调用
for !reqReader.IsEOF() {
    req, err := reqReader.ReadRequest()
    func() {
        requestContext, finishRequest := context.WithCancel(req.Context())
        defer finishRequest()
        // ...
    }()
}
```

### 4. 步骤执行顺序依赖未标注
**模式**：后续步骤依赖前面步骤的产出，但未明确标注依赖关系，执行者可能乱序执行
```
计划问题：
- 步骤2：修改 CoreHttpServer 添加 TunnelSessions 字段
- 步骤3：在 https.go 中使用 proxy.TunnelSessions.Store(...)
- 未标注：步骤3依赖步骤2，必须先完成步骤2

建议：在计划中明确标注步骤间的依赖关系，如"前置条件：步骤2已完成"
```

### 5. 与现有代码逻辑冲突
**模式**：计划中的新代码假设了与现有代码不同的前置条件或不变量
```
计划问题：
- 计划假设：调用该函数时连接已建立
- 现有代码：该函数可能在连接建立前被调用
- 结果：新代码在某些路径下会 panic 或产生错误行为

建议：读取现有代码的上下文，对比计划代码的假设是否成立；
      在计划中明确标注对现有代码的假设，并验证这些假设
```

---

## 发现潜在Bug后的处理

当在计划中发现潜在bug模式时：

1. **定位问题** - 指出计划中的具体位置
2. **解释风险** - 说明为什么这可能导致bug
3. **提供方案** - 给出具体的修复建议
4. **更新计划** - 修改计划以包含正确的处理

示例输出：
```markdown
### [P1] 潜在Bug：资源泄漏风险

**位置**：计划第15行 "创建文件连接并处理数据"

**风险**：计划中在成功路径关闭连接，但如果处理过程发生异常，
连接将不会被关闭，导致资源泄漏。

**建议**：使用defer/finally确保资源总是被释放：

```
defer conn.Close()
// 处理数据
```

**修订后**：在步骤中添加"使用defer确保连接关闭"
```